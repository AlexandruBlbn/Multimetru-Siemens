/*
 * Monitor Ritm Cardiac și Saturație Oxigen - MAX30102
 * Măsoară: BPM (bătăi pe minut) și SpO2 (% oxigen)
 * Arduino Mega 2560
 * Author: AlexandruBlbn
 */

#include <Wire.h>
#include "MAX30105.h"

MAX30105 particleSensor;

// ============ Variabile BPM ============
const byte RATE_SIZE = 4;
byte rates[RATE_SIZE];
byte rateSpot = 0;
float beatsPerMinute = 0;
int beatAvg = 0;
int beatCount = 0;
unsigned long lastBeatTime = 0;

// Detectare prin derivată
long irValue = 0;
long lastIR = 0;
long derivative = 0;
long lastDerivative = 0;

// Buffer pentru medie IR
const int AVG_SIZE = 5;
long irAvgBuffer[AVG_SIZE];
int avgIndex = 0;
long irSmooth = 0;

// ============ Variabile SpO2 ============
const byte SPO2_BUFFER_SIZE = 100;
uint32_t irBuffer[SPO2_BUFFER_SIZE];
uint32_t redBuffer[SPO2_BUFFER_SIZE];
int bufferIndex = 0;
bool bufferReady = false;

float SpO2 = 0;
int8_t validSpO2 = 0;
int32_t heartRate = 0;
int8_t validHeartRate = 0;

// Variabile pentru calcul SpO2
float redAC = 0;
float irAC = 0;
float redDC = 0;
float irDC = 0;
float ratio = 0;

void setup() {
  Serial.begin(115200);
  
  Serial.println("╔═══════════════════════════════════════════════════╗");
  Serial.println("║  Monitor Cardiac Complet - MAX30102              ║");
  Serial.println("║  BPM (Ritm Cardiac) + SpO2 (Saturație Oxigen)    ║");
  Serial.println("╚═══════════════════════════════════════════════════╝\n");
  
  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) {
    Serial.println("❌ MAX30102 nu răspunde!");
    Serial.println("Verifică conexiunile I2C (SDA=20, SCL=21)");
    while (1);
  }
  
  Serial.println("✓ Senzor MAX30102 inițializat!\n");
  
  // Configurare optimă pentru BPM și SpO2
  byte ledBrightness = 60;   // 0-255
  byte sampleAverage = 4;    // 1, 2, 4, 8, 16, 32
  byte ledMode = 2;          // 2 = Red + IR (necesar pentru SpO2)
  byte sampleRate = 100;     // 100 Hz
  int pulseWidth = 411;      // 411 μs
  int adcRange = 4096;       // 4096 (ADC)
  
  particleSensor.setup(ledBrightness, sampleAverage, ledMode, 
                       sampleRate, pulseWidth, adcRange);
  
  // Setare intensitate LED-uri
  particleSensor.setPulseAmplitudeRed(0x0A);   // LED roșu
  particleSensor.setPulseAmplitudeGreen(0);    // LED verde OFF
  
  Serial.println("📋 INSTRUCȚIUNI:");
  Serial.println("  1. Pune degetul UȘOR pe senzor (nu apăsa!)");
  Serial.println("  2. Ține nemișcat 15-20 secunde");
  Serial.println("  3. Respiră normal și relaxat");
  Serial.println("  4. Așteaptă stabilizarea valorilor\n");
  Serial.println("═══════════════════════════════════════════════════\n");
  
  // Inițializare buffere
  for (int i = 0; i < AVG_SIZE; i++) {
    irAvgBuffer[i] = 0;
  }
  for (int i = 0; i < SPO2_BUFFER_SIZE; i++) {
    irBuffer[i] = 0;
    redBuffer[i] = 0;
  }
  
  delay(2000);
}

void loop() {
  // Citire valori IR și Red
  irValue = particleSensor.getIR();
  long redValue = particleSensor.getRed();
  
  // Verifică dacă degetul este pe senzor
  if (irValue < 50000) {
    Serial.println("❌ Pune degetul pe senzor!");
    resetStats();
    delay(500);
    return;
  }
  
  // ========== DETECTARE BPM ==========
  
  // Medie glisantă pentru eliminare zgomot
  irAvgBuffer[avgIndex] = irValue;
  avgIndex = (avgIndex + 1) % AVG_SIZE;
  
  irSmooth = 0;
  for (int i = 0; i < AVG_SIZE; i++) {
    irSmooth += irAvgBuffer[i];
  }
  irSmooth /= AVG_SIZE;
  
  // Calculează derivata
  derivative = irSmooth - lastIR;
  
  // Detectare vârf (bătaie)
  if (lastDerivative > 0 && derivative < 0) {
    unsigned long currentTime = millis();
    unsigned long timeDiff = currentTime - lastBeatTime;
    
    if (timeDiff > 300 && timeDiff < 2000 && lastBeatTime > 0) {
      beatsPerMinute = 60000.0 / timeDiff;
      
      if (beatsPerMinute >= 40 && beatsPerMinute <= 180) {
        rates[rateSpot++] = (byte)beatsPerMinute;
        rateSpot %= RATE_SIZE;
        
        beatAvg = 0;
        int validBeats = 0;
        for (byte x = 0; x < RATE_SIZE; x++) {
          if (rates[x] > 0) {
            beatAvg += rates[x];
            validBeats++;
          }
        }
        if (validBeats > 0) {
          beatAvg /= validBeats;
        }
        
        beatCount++;
      }
    }
    
    lastBeatTime = currentTime;
  }
  
  lastDerivative = derivative;
  lastIR = irSmooth;
  
  // ========== CALCUL SpO2 ==========
  
  // Adaugă sample-uri în buffer circular
  irBuffer[bufferIndex] = irValue;
  redBuffer[bufferIndex] = redValue;
  bufferIndex++;
  
  if (bufferIndex >= SPO2_BUFFER_SIZE) {
    bufferIndex = 0;
    bufferReady = true;
  }
  
  // Calculează SpO2 doar când buffer-ul este plin
  if (bufferReady && beatCount >= 3) {
    calculateSpO2();
  }
  
  // ========== AFIȘARE DATE ==========
  
  Serial.print("IR=");
  Serial.print(irValue);
  Serial.print(" | Red=");
  Serial.print(redValue);
  Serial.print(" | ");
  
  // BPM
  Serial.print("❤️  BPM: ");
  if (beatAvg > 0) {
    Serial.print(beatAvg);
    Serial.print(" ");
  } else {
    Serial.print("--- ");
  }
  
  // SpO2
  Serial.print("| 🫁 SpO2: ");
  if (SpO2 > 0 && SpO2 <= 100) {
    Serial.print(SpO2, 1);
    Serial.print("% ");
    
    // Indicator calitate
    if (SpO2 >= 95) {
      Serial.print("✓ Normal");
    } else if (SpO2 >= 90) {
      Serial.print("⚠️  Scăzut");
    } else {
      Serial.print("❌ Critic");
    }
  } else {
    Serial.print("---%  ");
  }
  
  Serial.print(" | Bătăi: ");
  Serial.print(beatCount);
  
  // Status
  if (beatCount < 3) {
    Serial.print(" | ⏳ Calibrare...");
  } else if (beatAvg > 0 && SpO2 > 0) {
    Serial.print(" | ✓ STABIL");
  }
  
  Serial.println();
  
  delay(20);
}

// ========== FUNCȚIE CALCUL SpO2 ==========
void calculateSpO2() {
  // Găsește valorile AC (variație) și DC (medie)
  uint32_t irMax = 0, irMin = 999999;
  uint32_t redMax = 0, redMin = 999999;
  uint32_t irSum = 0, redSum = 0;
  
  for (int i = 0; i < SPO2_BUFFER_SIZE; i++) {
    // IR
    if (irBuffer[i] > irMax) irMax = irBuffer[i];
    if (irBuffer[i] < irMin) irMin = irBuffer[i];
    irSum += irBuffer[i];
    
    // Red
    if (redBuffer[i] > redMax) redMax = redBuffer[i];
    if (redBuffer[i] < redMin) redMin = redBuffer[i];
    redSum += redBuffer[i];
  }
  
  // AC = amplitudine (max - min)
  irAC = irMax - irMin;
  redAC = redMax - redMin;
  
  // DC = valoare medie
  irDC = irSum / SPO2_BUFFER_SIZE;
  redDC = redSum / SPO2_BUFFER_SIZE;
  
  // Calculează raportul R
  // R = (Red_AC / Red_DC) / (IR_AC / IR_DC)
  if (irDC != 0 && redDC != 0 && irAC != 0) {
    float redRatio = redAC / redDC;
    float irRatio = irAC / irDC;
    
    if (irRatio != 0) {
      ratio = redRatio / irRatio;
      
      // Formula empirică pentru SpO2
      // SpO2 = 110 - 25 * R (aproximativ)
      // Sau formula mai precisă:
      SpO2 = 104 - 17 * ratio;
      
      // Limitare la valori realiste
      if (SpO2 > 100) SpO2 = 100;
      if (SpO2 < 70) SpO2 = 0; // Sub 70% este probabil eroare
    }
  }
}

// ========== FUNCȚIE RESET ==========
void resetStats() {
  beatsPerMinute = 0;
  beatAvg = 0;
  beatCount = 0;
  lastBeatTime = 0;
  rateSpot = 0;
  SpO2 = 0;
  bufferIndex = 0;
  bufferReady = false;
  
  for (byte x = 0; x < RATE_SIZE; x++) {
    rates[x] = 0;
  }
  for (int i = 0; i < SPO2_BUFFER_SIZE; i++) {
    irBuffer[i] = 0;
    redBuffer[i] = 0;
  }
}